#!/bin/bash

set -eo pipefail

# If using a locally built stateless CI container, export ANCHORE_CI_IMAGE=<image_name>. 
# This will override the image name from Dockerhub.
stateless_anchore_image="${ANCHORE_CI_IMAGE:-docker.io/anchore/private_testing:stateless_ci}"

display_usage() {
cat << EOF
  
Stateless Anchore Engine --

  Script for performing vulnerability analysis on local docker images, utilizing Anchore Engine in stateless mode.  
  
  Images should be built & tagged locally, or remote images can be pulled with the -r option.

  
  Usage: ${0##*/} [ -f ] [ -r ] [ -d ./Dockerfile ] [ -p ./policy.json ] [ IMAGE_ONE ] [ IMAGE_TWO ... ]

      -d  (optional) Path to local Dockerfile
      -p  (optional) Path to local Anchore policy bundle
      -f  (optional) Exit script upon failed Anchore policy evaluation
      -r  (optional) Pull remote docker images
 
EOF
}

error() {
    cleanup 130
}

cleanup() {
    set +e
    if [[ -z "$1" ]] && [[ -z "$ret" ]]; then
        ret="$?"
    elif [[ -z "$ret" ]]; then
        ret="$1"
    fi
    
    if [[ -z "$docker_id" ]]; then
        docker_id="${docker_name:-$(docker ps -a | grep 'stateless-anchore-engine' | awk '{print $1}')}"
    fi
    if [[ ! -z "$docker_id" ]]; then
        for i in $docker_id; do
            declare timeout=0
            while (docker ps -a | grep -q "$docker_id") || [[ "$timeout" -gt 12 ]]; do
                docker kill "$i" &> /dev/null
                docker rm "$i" &> /dev/null
                printf '\n%s\n' "Cleaning up docker container: $docker_id"
                timeout+=1
                sleep 5
            done

            if [[ "$timeout" -gt 12 ]]; then
                exit 1
            fi
            unset docker_id
        done
    fi
    
    if [[ -f "/tmp/${file_name}" ]]; then
        rm "/tmp/${file_name}"
    fi
    
    set -e
    exit "$ret"
}

trap 'cleanup' EXIT 
trap 'error' SIGTERM SIGINT

# Parse options
while getopts ':d:p:fhr' option; do
  case "$option" in
    h  ) display_usage; exit;;
    d  ) d_flag=true; dockerfile="$OPTARG";;
    f  ) f_flag=true;;
    p  ) p_flag=true; policy_bundle="$OPTARG";;
    r  ) r_flag=true;;
    \? ) printf "\n\t%s\n\n" "  Invalid option: -${OPTARG}" >&2; display_usage >&2; exit 1;;
    :  ) printf "\n\t%s\n\n%s\n\n" "  Option -${OPTARG} requires an argument." >&2; display_usage >&2; exit 1;;
  esac
done

shift "$((OPTIND - 1))"

if [[ ! $(which docker) ]]; then
    printf '\n\t%s\n\n' 'ERROR - Docker is not installed or cannot be found in $PATH.' >&2
    display_usage >&2
    exit 1
elif [[ "${#@}" -eq 0 ]]; then
    printf '\n\t%s\n\n' "ERROR - ${0##*/} requires at least 1 image name as input." >&2
    display_usage >&2
    exit 1
elif [[ "$d_flag" ]] && [[ "${#@}" -gt 1 ]]; then
    printf '\n\t%s\n\n' 'ERROR - If specifying a Dockerfile, only 1 image can be scanned at a time.' >&2
    display_usage >&2
    exit 1
fi

image_names=()
failed_images=()
scan_images=()

main() {
    for i in "$@"; do
        if [[ ! "${image_names[@]}" =~ "$i" ]]; then
            image_names+=("$i")
        fi
    done

    if [[ "$r_flag" ]]; then
        for i in "${image_names[@]}"; do
            docker pull "$i"
        done
    fi

    for i in "${image_names[@]}"; do
        docker inspect "$i" &> /dev/null || failed_images+=("$i")

        if [[ ! "${failed_images[@]}" =~ "$i" ]]; then
            scan_images+=("$i")
        fi
    done

    if [[ "${#failed_images[@]}" -gt 0 ]]; then
        printf '\n\t%s\n\n' "### Please pull remote image, or build/tag all local images before attempting analysis again. ###" >&2

        if [[ "${#failed_images[@]}" -ge "${#image_names[@]}" ]]; then
            printf '\n\t%s\n\n' "ERROR - no local docker images specified in script input: $0 ${image_names[*]}" >&2
            display_usage >&2
            exit 1
        fi

        for i in "${failed_images[@]}"; do
            printf '\t\t%s\n' "Could not find image locally - $i" >&2
        done
        echo
    fi

    if [[ -z "$ANCHORE_CI_IMAGE" ]]; then
        docker pull "$stateless_anchore_image"
    fi

    docker_name="${RANDOM:-TEMP}-stateless-anchore-engine"
    if [[ ! "$d_flag" ]] && [[ ! "$p_flag" ]] && [[ "${#scan_images[@]}" -eq 1 ]]; then
        printf '\n%s\n' "Preparing image for analysis -- ${scan_images[*]}"
        docker save "$i" | docker run -i --name "$docker_name" "$stateless_anchore_image" -i"${scan_images[*]}"
    else
        copy_cmds=()
        create_cmd=('docker create --name "$docker_name" "$stateless_anchore_image"')

        if [[ "$p_flag" ]]; then
            create_cmd+=('-p"$policy_bundle"')
            copy_cmds+=('docker cp "$policy_bundle" "${docker_name}:/anchore-engine/$(basename $policy_bundle)";')
        fi
        
        if [[ "$f_flag" ]]; then
            create_cmd+=('-f')
        fi
        
        if [[ "$d_flag" ]]; then
            create_cmd+=('-d"$dockerfile" -i"${scan_images[*]}"')
            copy_cmds+=('docker cp "$dockerfile" "${docker_name}:/anchore-engine/$(basename $dockerfile)";')
        fi
        
        docker_id=$(eval "${create_cmd[*]}")
        eval "${copy_cmds[*]}"
        echo
        for image in "${scan_images[@]}"; do
            echo "Preparing image for analysis -- $image"
            repo=$(basename "${image%:*}")
            tag="${image#*:}"
            file_name="${repo}+${tag}.tar" 
            load_container "$image" "$file_name"
        done
        docker start -ia "$docker_name"
    fi
    
    echo "Copying analysis reports from ${docker_name} to ${PWD}/anchore-reports/"
    docker cp "${docker_name}:/anchore-engine/anchore-reports/" ./
}


load_container() {
    declare image="$1"
    declare file="$2"
    docker save "$image" -o "/tmp/${file}"
    
    if [[ -f "/tmp/${file}" ]]; then
        docker cp "/tmp/${file}" "${docker_name}:/anchore-engine/${file}"
        rm -f "/tmp/${file}"
    else
        printf '\n\t%s\n\n' "ERROR - unable to save docker image to /tmp/${file}." >&2
        display_usage >&2
        exit 1
    fi
}

main "$@"